"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.onEnd = exports.onPostBuild = exports.onBuild = void 0;
const promises_1 = __importDefault(require("node:fs/promises"));
const node_path_1 = __importDefault(require("node:path"));
const glob_1 = require("glob");
const p_limit_1 = __importDefault(require("p-limit"));
const cloudinary_1 = require("./lib/cloudinary");
const util_1 = require("./lib/util");
const cloudinary_2 = require("./data/cloudinary");
const errors_1 = require("./data/errors");
const CLOUDINARY_ASSET_DIRECTORIES = [
    {
        name: 'images',
        inputKey: 'imagesPath',
        path: '/images',
    },
];
const DEFAULT_CONCURRENCY = 10;
/**
 * TODO
 * - Handle srcset
 */
const _cloudinaryAssets = { images: {} };
const globalErrors = [];
async function onBuild({ netlifyConfig, constants, inputs, utils, }) {
    console.log('[Cloudinary] Creating redirects...');
    let host = process.env.URL;
    if (process.env.CONTEXT === 'branch-deploy' || process.env.CONTEXT === 'deploy-preview') {
        host = process.env.DEPLOY_PRIME_URL || '';
    }
    console.log(`[Cloudinary] Using host: ${host}`);
    const { PUBLISH_DIR } = constants;
    const { cname, deliveryType, folder = process.env.SITE_NAME || '', imagesPath = inputs.imagesPath || CLOUDINARY_ASSET_DIRECTORIES.find(({ inputKey }) => inputKey === 'imagesPath')?.path, maxSize, privateCdn, uploadPreset, uploadConcurrency = DEFAULT_CONCURRENCY, } = inputs;
    if (!folder) {
        console.error(`[Cloudinary] ${errors_1.ERROR_SITE_NAME_REQUIRED}`);
        utils.build.failPlugin(errors_1.ERROR_SITE_NAME_REQUIRED);
        return;
    }
    if (!host && deliveryType === 'fetch') {
        console.warn(`[Cloudinary] ${errors_1.ERROR_NETLIFY_HOST_UNKNOWN}`);
        console.log(`[Cloudinary] ${errors_1.ERROR_NETLIFY_HOST_CLI_SUPPORT}`);
        return;
    }
    const cloudName = process.env.CLOUDINARY_CLOUD_NAME || inputs.cloudName;
    const apiKey = process.env.CLOUDINARY_API_KEY;
    const apiSecret = process.env.CLOUDINARY_API_SECRET;
    if (!cloudName) {
        console.error(`[Cloudinary] ${errors_1.ERROR_CLOUD_NAME_REQUIRED}`);
        utils.build.failBuild(errors_1.ERROR_CLOUD_NAME_REQUIRED);
        return;
    }
    if (deliveryType === 'upload' && (!apiKey || !apiSecret)) {
        console.error(`[Cloudinary] ${errors_1.ERROR_API_CREDENTIALS_REQUIRED}`);
        utils.build.failBuild(errors_1.ERROR_API_CREDENTIALS_REQUIRED);
        return;
    }
    (0, cloudinary_1.configureCloudinary)({
        // Base credentials
        cloudName,
        apiKey,
        apiSecret,
        // Configuration
        cname,
        privateCdn,
    });
    const transformations = (0, cloudinary_1.getTransformationsFromInputs)(inputs);
    // Look for any available images in the provided imagesPath to collect
    // asset details and to grab a Cloudinary URL to use later
    if (typeof imagesPath === 'undefined') {
        console.error(`[Cloudinary] ${errors_1.ERROR_INVALID_IMAGES_PATH}`);
        throw new Error(errors_1.ERROR_INVALID_IMAGES_PATH);
    }
    const imagesFiles = (0, util_1.findAssetsByPath)({
        baseDir: PUBLISH_DIR,
        path: imagesPath,
    });
    if (imagesFiles.length === 0) {
        console.warn(`[Cloudinary] No image files found in ${imagesPath}`);
        console.log(`[Cloudinary] Did you update your images path? You can set the imagesPath input in your Netlify config.`);
    }
    const limitUploadFiles = (0, p_limit_1.default)(uploadConcurrency);
    const uploadsQueue = imagesFiles.map((image, i) => {
        const publishPath = image.replace(PUBLISH_DIR, '');
        return limitUploadFiles(() => {
            async function uploadFile() {
                try {
                    const cloudinary = await (0, cloudinary_1.getCloudinaryUrl)({
                        deliveryType,
                        folder,
                        path: publishPath,
                        localDir: PUBLISH_DIR,
                        uploadPreset,
                        remoteHost: host,
                        transformations
                    });
                    return {
                        publishPath,
                        ...cloudinary,
                    };
                }
                catch (e) {
                    globalErrors.push(e);
                }
            }
            return uploadFile();
        });
    });
    _cloudinaryAssets.images = await Promise.all(uploadsQueue);
    // If the delivery type is set to upload, we need to be able to map individual assets based on their public ID,
    // which would require a dynamic middle solution, but that adds more hops than we want, so add a new redirect
    // for each asset uploaded
    if (deliveryType === 'upload') {
        await Promise.all(Object.keys(_cloudinaryAssets).flatMap(mediaType => {
            // @ts-expect-error what are the expected mediaTypes that will be stored in _cloudinaryAssets
            if (Object.hasOwn(_cloudinaryAssets[mediaType], 'map')) {
                // @ts-expect-error what are the expected mediaTypes that will be stored in _cloudinaryAssets
                return _cloudinaryAssets[mediaType].map(async (asset) => {
                    const { publishPath, cloudinaryUrl } = asset;
                    netlifyConfig.redirects.unshift({
                        from: `${publishPath}*`,
                        to: cloudinaryUrl,
                        status: 302,
                        force: true,
                    });
                });
            }
        }));
    }
    // If the delivery type is fetch, we're able to use the public URL and pass it right along "as is", so
    // we can create generic redirects. The tricky thing is to avoid a redirect loop, we modify the
    // path, so that we can safely allow Cloudinary to fetch the media remotely
    if (deliveryType === 'fetch') {
        await Promise.all(CLOUDINARY_ASSET_DIRECTORIES.map(async ({ inputKey, path: defaultPath }) => {
            let mediaPaths = inputs[inputKey] || defaultPath;
            // Unsure how to type the above so that Inputs['privateCdn'] doesnt mess up types here
            if (!Array.isArray(mediaPaths) && typeof mediaPaths !== 'string')
                return;
            if (!Array.isArray(mediaPaths)) {
                mediaPaths = [mediaPaths];
            }
            mediaPaths.forEach(async (mediaPath) => {
                mediaPath = mediaPath.split(node_path_1.default.win32.sep).join(node_path_1.default.posix.sep);
                const cldAssetPath = `/${node_path_1.default.posix.join(cloudinary_2.PUBLIC_ASSET_PATH, mediaPath)}`;
                const cldAssetUrl = `${host}${cldAssetPath}`;
                try {
                    const { cloudinaryUrl: assetRedirectUrl } = await (0, cloudinary_1.getCloudinaryUrl)({
                        deliveryType: 'fetch',
                        folder,
                        path: `${cldAssetUrl}/:splat`,
                        uploadPreset,
                    });
                    netlifyConfig.redirects.unshift({
                        from: `${cldAssetPath}/*`,
                        to: `${mediaPath}/:splat`,
                        status: 200,
                        force: true,
                    });
                    netlifyConfig.redirects.unshift({
                        from: `${mediaPath}/*`,
                        to: assetRedirectUrl,
                        status: 302,
                        force: true,
                    });
                }
                catch (error) {
                    globalErrors.push(error);
                }
            });
        }));
    }
}
exports.onBuild = onBuild;
// Post build looks through all of the output HTML and rewrites any src attributes to use a cloudinary URL
// This only solves on-page references until any JS refreshes the DOM
async function onPostBuild({ constants, inputs, utils, }) {
    console.log('[Cloudinary] Replacing on-page images with Cloudinary URLs...');
    let host = process.env.URL;
    if (process.env.CONTEXT === 'branch-deploy' || process.env.CONTEXT === 'deploy-preview') {
        host = process.env.DEPLOY_PRIME_URL || '';
    }
    console.log(`[Cloudinary] Using host: ${host}`);
    const { PUBLISH_DIR } = constants;
    const { cname, deliveryType, folder = process.env.SITE_NAME, loadingStrategy = inputs.loadingStrategy || 'lazy', privateCdn, uploadPreset, } = inputs;
    if (!folder) {
        console.error(`[Cloudinary] ${errors_1.ERROR_SITE_NAME_REQUIRED}`);
        utils.build.failPlugin(errors_1.ERROR_SITE_NAME_REQUIRED);
        return;
    }
    const cloudName = process.env.CLOUDINARY_CLOUD_NAME || inputs.cloudName;
    const apiKey = process.env.CLOUDINARY_API_KEY;
    const apiSecret = process.env.CLOUDINARY_API_SECRET;
    if (!cloudName) {
        console.error(`[Cloudinary] ${errors_1.ERROR_CLOUD_NAME_REQUIRED}`);
        utils.build.failBuild(errors_1.ERROR_CLOUD_NAME_REQUIRED);
        return;
    }
    if (deliveryType === 'upload' && (!apiKey || !apiSecret)) {
        console.error(`[Cloudinary] ${errors_1.ERROR_API_CREDENTIALS_REQUIRED}`);
        utils.build.failBuild(errors_1.ERROR_API_CREDENTIALS_REQUIRED);
        return;
    }
    (0, cloudinary_1.configureCloudinary)({
        // Base credentials
        cloudName,
        apiKey,
        apiSecret,
        // Configuration
        cname,
        privateCdn,
    });
    const transformations = (0, cloudinary_1.getTransformationsFromInputs)(inputs);
    // Find all HTML source files in the publish directory
    const pages = glob_1.glob.sync(`${PUBLISH_DIR}/**/*.html`);
    const results = await Promise.all(pages.map(async (page) => {
        const sourceHtml = await promises_1.default.readFile(page, 'utf-8');
        const { html, errors } = await (0, cloudinary_1.updateHtmlImagesToCloudinary)(sourceHtml, {
            assets: _cloudinaryAssets,
            deliveryType,
            uploadPreset,
            folder,
            loadingStrategy,
            localDir: PUBLISH_DIR,
            remoteHost: host,
            transformations
        });
        await promises_1.default.writeFile(page, html);
        return {
            page,
            errors,
        };
    }));
    const errors = results.filter(({ errors }) => errors.length > 0);
    // Collect the errors in the global scope to be used in the summary onEnd
    globalErrors.push(...errors);
}
exports.onPostBuild = onPostBuild;
function onEnd({ utils }) {
    const summary = globalErrors.length > 0 ? `Cloudinary build plugin completed with ${globalErrors.length} errors` : "Cloudinary build plugin completed successfully";
    const text = globalErrors.length > 0 ? `The build process found ${globalErrors.length} errors. Check build logs for more information` : "No errors found during build";
    utils.status.show({
        title: "[Cloudinary] Done.",
        // Required.
        summary,
        text
    });
}
exports.onEnd = onEnd;
